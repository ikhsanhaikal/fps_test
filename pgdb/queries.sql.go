// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: queries.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createKategori = `-- name: CreateKategori :one
INSERT INTO kategori (
  nama_kategori 
) VALUES (
  $1 
)
RETURNING id_kategori, nama_kategori
`

func (q *Queries) CreateKategori(ctx context.Context, namaKategori string) (Kategori, error) {
	row := q.db.QueryRow(ctx, createKategori, namaKategori)
	var i Kategori
	err := row.Scan(&i.IDKategori, &i.NamaKategori)
	return i, err
}

const createProduk = `-- name: CreateProduk :one
INSERT INTO produk (
  nama_produk, harga, kategori_id, status_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING id_produk as id, nama_produk, harga, kategori_id, status_id
`

type CreateProdukParams struct {
	NamaProduk string         `json:"nama_produk"`
	Harga      pgtype.Numeric `json:"harga"`
	KategoriID int64          `json:"kategori_id"`
	StatusID   int64          `json:"status_id"`
}

type CreateProdukRow struct {
	ID         int32          `json:"id"`
	NamaProduk string         `json:"nama_produk"`
	Harga      pgtype.Numeric `json:"harga"`
	KategoriID int64          `json:"kategori_id"`
	StatusID   int64          `json:"status_id"`
}

func (q *Queries) CreateProduk(ctx context.Context, arg CreateProdukParams) (CreateProdukRow, error) {
	row := q.db.QueryRow(ctx, createProduk,
		arg.NamaProduk,
		arg.Harga,
		arg.KategoriID,
		arg.StatusID,
	)
	var i CreateProdukRow
	err := row.Scan(
		&i.ID,
		&i.NamaProduk,
		&i.Harga,
		&i.KategoriID,
		&i.StatusID,
	)
	return i, err
}

const createStatus = `-- name: CreateStatus :one
INSERT INTO status (
  nama_status
) VALUES (
  $1
)
RETURNING id_status, nama_status
`

func (q *Queries) CreateStatus(ctx context.Context, namaStatus string) (Status, error) {
	row := q.db.QueryRow(ctx, createStatus, namaStatus)
	var i Status
	err := row.Scan(&i.IDStatus, &i.NamaStatus)
	return i, err
}

const deleteProduk = `-- name: DeleteProduk :one
DELETE FROM produk
WHERE id_produk = $1
RETURNING id_produk as id, nama_produk, harga, kategori_id, status_id
`

type DeleteProdukRow struct {
	ID         int32          `json:"id"`
	NamaProduk string         `json:"nama_produk"`
	Harga      pgtype.Numeric `json:"harga"`
	KategoriID int64          `json:"kategori_id"`
	StatusID   int64          `json:"status_id"`
}

func (q *Queries) DeleteProduk(ctx context.Context, idProduk int32) (DeleteProdukRow, error) {
	row := q.db.QueryRow(ctx, deleteProduk, idProduk)
	var i DeleteProdukRow
	err := row.Scan(
		&i.ID,
		&i.NamaProduk,
		&i.Harga,
		&i.KategoriID,
		&i.StatusID,
	)
	return i, err
}

const getKategoriById = `-- name: GetKategoriById :one
SELECT id_kategori, nama_kategori from kategori 
WHERE id_kategori = $1
`

func (q *Queries) GetKategoriById(ctx context.Context, idKategori int32) (Kategori, error) {
	row := q.db.QueryRow(ctx, getKategoriById, idKategori)
	var i Kategori
	err := row.Scan(&i.IDKategori, &i.NamaKategori)
	return i, err
}

const getKategoriByIds = `-- name: GetKategoriByIds :many
SELECT id_kategori as id , nama_kategori from kategori 
WHERE id_kategori = ANY($1::int[])
`

type GetKategoriByIdsRow struct {
	ID           int32  `json:"id"`
	NamaKategori string `json:"nama_kategori"`
}

func (q *Queries) GetKategoriByIds(ctx context.Context, ids []int32) ([]GetKategoriByIdsRow, error) {
	rows, err := q.db.Query(ctx, getKategoriByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKategoriByIdsRow
	for rows.Next() {
		var i GetKategoriByIdsRow
		if err := rows.Scan(&i.ID, &i.NamaKategori); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProdukById = `-- name: GetProdukById :one
SELECT id_produk as id, nama_produk, harga, kategori_id, status_id from produk 
WHERE id_produk = $1
`

type GetProdukByIdRow struct {
	ID         int32          `json:"id"`
	NamaProduk string         `json:"nama_produk"`
	Harga      pgtype.Numeric `json:"harga"`
	KategoriID int64          `json:"kategori_id"`
	StatusID   int64          `json:"status_id"`
}

func (q *Queries) GetProdukById(ctx context.Context, idProduk int32) (GetProdukByIdRow, error) {
	row := q.db.QueryRow(ctx, getProdukById, idProduk)
	var i GetProdukByIdRow
	err := row.Scan(
		&i.ID,
		&i.NamaProduk,
		&i.Harga,
		&i.KategoriID,
		&i.StatusID,
	)
	return i, err
}

const getStatusByIds = `-- name: GetStatusByIds :many
SELECT id_status as id , nama_status from status 
WHERE id_status = ANY($1::int[])
`

type GetStatusByIdsRow struct {
	ID         int32  `json:"id"`
	NamaStatus string `json:"nama_status"`
}

func (q *Queries) GetStatusByIds(ctx context.Context, ids []int32) ([]GetStatusByIdsRow, error) {
	rows, err := q.db.Query(ctx, getStatusByIds, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusByIdsRow
	for rows.Next() {
		var i GetStatusByIdsRow
		if err := rows.Scan(&i.ID, &i.NamaStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKategori = `-- name: ListKategori :many
SELECT id_kategori as id, nama_kategori FROM kategori 
ORDER BY id LIMIT $1 OFFSET $2
`

type ListKategoriParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListKategoriRow struct {
	ID           int32  `json:"id"`
	NamaKategori string `json:"nama_kategori"`
}

func (q *Queries) ListKategori(ctx context.Context, arg ListKategoriParams) ([]ListKategoriRow, error) {
	rows, err := q.db.Query(ctx, listKategori, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKategoriRow
	for rows.Next() {
		var i ListKategoriRow
		if err := rows.Scan(&i.ID, &i.NamaKategori); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProduk = `-- name: ListProduk :many
SELECT id_produk as id, nama_produk, harga, kategori_id, status_id, created_at FROM produk
ORDER BY id LIMIT $1 OFFSET $2
`

type ListProdukParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProdukRow struct {
	ID         int32            `json:"id"`
	NamaProduk string           `json:"nama_produk"`
	Harga      pgtype.Numeric   `json:"harga"`
	KategoriID int64            `json:"kategori_id"`
	StatusID   int64            `json:"status_id"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListProduk(ctx context.Context, arg ListProdukParams) ([]ListProdukRow, error) {
	rows, err := q.db.Query(ctx, listProduk, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProdukRow
	for rows.Next() {
		var i ListProdukRow
		if err := rows.Scan(
			&i.ID,
			&i.NamaProduk,
			&i.Harga,
			&i.KategoriID,
			&i.StatusID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatus = `-- name: ListStatus :many
SELECT id_status as id, nama_status FROM status 
ORDER BY id LIMIT $1 OFFSET $2
`

type ListStatusParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListStatusRow struct {
	ID         int32  `json:"id"`
	NamaStatus string `json:"nama_status"`
}

func (q *Queries) ListStatus(ctx context.Context, arg ListStatusParams) ([]ListStatusRow, error) {
	rows, err := q.db.Query(ctx, listStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStatusRow
	for rows.Next() {
		var i ListStatusRow
		if err := rows.Scan(&i.ID, &i.NamaStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalProduk = `-- name: TotalProduk :one
SELECT COUNT(*) AS total FROM produk
`

func (q *Queries) TotalProduk(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalProduk)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const updateProduk = `-- name: UpdateProduk :one
UPDATE produk SET
  nama_produk = COALESCE($2, nama_produk),
  harga = COALESCE($3, harga),
  kategori_id = COALESCE($4, kategori_id),
  status_id = COALESCE($5, status_id)
WHERE id_produk = $1
RETURNING id_produk as id, nama_produk, harga, kategori_id, status_id
`

type UpdateProdukParams struct {
	Id         int32          `json:"id_produk"`
	NamaProduk pgtype.Text    `json:"nama_produk"`
	Harga      pgtype.Numeric `json:"harga"`
	KategoriID pgtype.Int8    `json:"kategori_id"`
	StatusID   pgtype.Int8    `json:"status_id"`
}

type UpdateProdukRow struct {
	ID         int32          `json:"id"`
	NamaProduk string         `json:"nama_produk"`
	Harga      pgtype.Numeric `json:"harga"`
	KategoriID int64          `json:"kategori_id"`
	StatusID   int64          `json:"status_id"`
}

func (q *Queries) UpdateProduk(ctx context.Context, arg UpdateProdukParams) (UpdateProdukRow, error) {
	row := q.db.QueryRow(ctx, updateProduk,
		arg.Id,
		arg.NamaProduk,
		arg.Harga,
		arg.KategoriID,
		arg.StatusID,
	)
	var i UpdateProdukRow
	err := row.Scan(
		&i.ID,
		&i.NamaProduk,
		&i.Harga,
		&i.KategoriID,
		&i.StatusID,
	)
	return i, err
}
